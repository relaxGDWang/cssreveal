<!DOCTYPE html>
<html lang="zh" xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>垫片绘制</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
<style type="text/css">
*{ box-sizing:border-box;}
html,body{ padding:0; margin:0;}
svg{ border:1px solid #999; margin:10px;}
svg .backShow{ stroke:#666; fill:#fff;}
svg .sealing{ stroke:#000;}
svg .sealing:hover{ stroke:red; stroke-width:2;}
svg .sealing .partLeft{ fill:url(#leftPattern);}
svg .sealing .partRight{ fill:url(#rightPattern);}
svg .sealing rect{ fill:#ccc;}
svg pattern{ stroke:#333; stroke-width:1; fill:none;}
svg line{ stroke:#999; stroke-width:1;}

svg #grid{ stroke-width:0.5; stroke:#666; fill:none;}  /*网格样式*/
svg #outRing{ stroke-width:1; stroke:#000; fill:url(#metalPatternTRBL);}  /* 外环样式 */

</style>
</head>
<body>
    <div class="show">
		<svg id="gasket" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
			<defs>
				<pattern id="spiralPattern" patternUnits="userSpaceOnUse"></pattern>
				<pattern id="leftSpiral" xlink:href="#spiralPattern"></pattern>
				<pattern id="rightSpiral" xlink:href="#spiralPattern"></pattern>
				<pattern id="metalPatternTRBL" patternUnits="userSpaceOnUse"></pattern>
				<pattern id="metalPatternTLBR" xlink:href="#metalPatternTRBL" patternTransform="rotate(90)"></pattern>
			</defs>
		</svg>
	</div>
<script src="jquery-1.12.4.min.js"></script>
<script>
var allW=800;
var allH=400;
var svg=$('#gasket')[0];
svg.setAttribute('width',allW);
svg.setAttribute('height',allH);

createGrid(svg,50);

var angle=60;  //角度
var gasket={d1:100,d2:180,d3:420,d4:700,e:60,E:34};  //垫片默认尺寸

//绘制金属底纹
drawMetalPattern($('svg #metalPatternTRBL')[0],60,10);
//绘制缠绕底纹
var patternHeight=drawSpiralPattern($('svg #spiralPattern')[0],30,10);
//垂直居中图案
$('svg #leftSpiral')[0].setAttribute('patternTransform','translate(0,-'+(patternHeight-gasket.e)/2+')');
$('svg #rightSpiral')[0].setAttribute('patternTransform','translate(5,-'+(patternHeight-gasket.e)/2+') rotate(180)');
//绘制外环
(function(){
	let h=(gasket.e-gasket.E)/2;
	let attr={
		x: 0,
		y: h,
		width: gasket.d4,
		height: gasket.E+h,
		id: 'outRing'
	};
	var outRing=createPath('rect',attr);
	svg.appendChild(outRing);
})();
//绘制缠绕垫
(function(){
	
})();


//绘制缠绕底纹
//pattern SVG中设置的底纹dom对象
//w底纹宽度，底纹高度会按角度值自行计算
//perW每个箭头线的水平间隔举例，请以能被w整除来进行设置
function drawSpiralPattern(pattern,w,perW){
	var g=createPath('g');
	var count=w/perW*2+1;
	var h=Math.tan(Math.PI/180*angle)*w;
	var p=[];
	p[0]=[[0,0],[-w,h],[0,h*2]];
	for (let i=1; i<count; i++){
		p[i]=[[],[],[]];
		for (let j=0; j<p[i].length; j++){
			let temp=p[i][j]=[];
			temp[0]=p[0][j][0]+perW*i;
			temp[1]=p[0][j][1];
		}
	}
	for (let i=0; i<count; i++){
		p[i][0]=p[i][0].join(',');
		p[i][1]=p[i][1].join(',');
		p[i][2]=p[i][2].join(',');
		p[i]=p[i].join(' ');
		let temp=createPath('polyline',{
			points: p[i]
		});
		g.appendChild(temp);
	}
	pattern.appendChild(g);
	pattern.setAttribute('width',w);
	pattern.setAttribute('height',h*2);
	pattern.setAttribute('viewbox','0 0 '+w+' '+h*2);
	return h*2;
}

//绘制金属底纹
function drawMetalPattern(pattern,w,perW){
	var g=createPath('g');
	var count=w/perW*2+1;
	var h=Math.tan(Math.PI/180*45)*w;
	for (let i=0; i<count; i++){
		var temp={};
		temp.x1=-w+i*perW;
		temp.y1=h;
		temp.x2=0+i*perW;
		temp.y2=0;
		var line=createPath('line',temp);
		g.appendChild(line);
	}
	pattern.appendChild(g);
	pattern.setAttribute('width',w);
	pattern.setAttribute('height',h);
	pattern.setAttribute('viewbox','0 0 '+w+' '+h);
	return h;
}


//建立svg标签对象
function createPath(name,attr){
	var temp=document.createElementNS('http://www.w3.org/2000/svg',name);
	for (let x in attr){
		temp.setAttribute(x,attr[x]);
	}
	return temp;
}

//绘制基本型垫片
//type A,B,C,D
//size d1,d2,d3,d4,E,e
function drawGasketA(type,size){
	var gAll=createPath('g',{class:'outframe'});
	var gSealing=createPath('g',{class:'sealing'});
	var gOutside=createPath('g',{class:'outside'});
	var gInside=createPath('g',{class:'inside'});
	
	//计算x轴方向侵入偏移
	var xp=size.e/2/Math.tan(Math.PI/180*60);
	var xp2=size.E/2/Math.tan(Math.PI/180*60);
	
	//绘制底部背景
	let pointsArray=markPoints({w:size.d3,h:size.e},'middle',{x:(size.d4-size.d3)/2-xp,y:0});
	var partMiddle=createPath('polygon',{
		points:pointsArray.join(' '),
		class:'backShow'
	});
	
	//绘制密封圈左侧
	var perGS=(size.d3-size.d2)/2;
	pointsArray=markPoints({w:perGS,h:size.e},'left',{x:(size.d4-size.d3)/2-xp,y:0});
	var partLeft=createPath('polygon',{
		class: 'partLeft',
		points:pointsArray.join(' ')
	});
	
	//绘制密封圈右侧
	pointsArray=markPoints({w:perGS,h:size.e},'right',{x:(size.d4-size.d3)/2-xp+size.d3-perGS,y:0});
	var partRight=createPath('polygon',{
		class: 'partRight',
		points:pointsArray.join(' ')
	});
	
	//绘制内环
	var ringIn=createRing(size,'inside',{x:(size.d4-size.d2)/2,y:(size.e-size.E)/2});
	
	gSealing.appendChild(partMiddle);
	gSealing.appendChild(partLeft);
	gSealing.appendChild(partRight);
	gSealing.appendChild(ringIn);
	
	gAll.appendChild(gSealing);
	return gAll;
}

//size{w,h}   绘制缠绕垫片密封环
//op 箭头方向
//py{x,y} 偏移量
//angle 单层夹角
function markPoints(size,op,py,angle){
	if (!py) py={x:0,y:0};
	if (!angle) angle=60;
	
	var perY=size.h/2;
	var perX=perY/Math.tan(Math.PI/180*angle);
	var p=[];
	p[0]=[0,0];
	p[1]=[size.w,0];
	p[2]=[size.w,perY];
	p[3]=[size.w,size.h];
	p[4]=[0,size.h];
	p[5]=[0,perY];
	switch(op){
		case 'left':
			p[5][0]-=perX;
			p[2][0]-=perX;
			break;
		case 'right':
			p[5][0]+=perX;
			p[2][0]+=perX;
			break;
		case 'middle':
			p[5][0]-=perX;
			p[2][0]+=perX;
			break;
	}
	for (let i=0; i<p.length; i++){
		p[i][0]+=py.x;
		p[i][1]+=py.y;
		p[i]=p[i].join(',');
	}
	return p;
}

//建立内外环
function createRing(size,op,py){
	var pyEx=size.e/2/Math.tan(Math.PI/180*60);
	var pointsArray=setPoints({w:(size.d2-size.d1)/2,h:size.E},'left',py);
	var leftPart=createPath('polygon',{
		points:pointsArray.join(' '),
		fill:'#f90'
	});
	return leftPart;
	
	function setPoints(size,op,py,angle){
		if (!py) py={x:0,y:0};
		if (!angle) angle=60;

		var perY=size.h/2;
		var perX=perY/Math.tan(Math.PI/180*angle);
		var p=[];
		p[0]=[0,0];
		p[1]=[size.w,0];
		p[2]=[size.w,perY];
		p[3]=[size.w,size.h];
		p[4]=[0,size.h];
		p[5]=[0,perY];
		console.log(p);
		switch(op){
			case 'left':
				p[0][0]-=pyEx;
				p[5][0]-=(perX+pyEx);
				p[4][0]-=pyEx;
				break;
			case 'right':
				p[2][0]+=perX;
		}
		for (let i=0; i<p.length; i++){
			p[i][0]+=py.x;
			p[i][1]+=py.y;
			p[i]=p[i].join(',');
		}
		return p;
	}
}

//绘制网格
function createGrid(svg,per){
	var g=createPath('g',{
		id: 'grid'
	});
	var w=svg.getAttribute('width')-0;
	var h=svg.getAttribute('height')-0;
	for (let i=per; i<=h; i+=per){
		let temp=createPath('line',{
			x1:0,
			y1:i,
			x2:w,
			y2:i,
		});
		g.appendChild(temp);
	}
	for (let i=per; i<=w; i+=per){
		let temp=createPath('line',{
			x1:i,
			y1:0,
			x2:i,
			y2:h,
		});
		g.appendChild(temp);
	}
	svg.appendChild(g);
}

/*
var gasket={d1:100,d2:180,d3:420,d4:700,e:60,E:34};
var g=drawGasketA('D',gasket);

//居中g
var mw=(allW-gasket.d4)/2;
var mh=(allH-gasket.e)/2;
//g.setAttribute('transform','translate('+mw+' '+mh+')');
svg.appendChild(g);

var ph=drawPattern(30,10);
//居中图案
$('#leftPattern')[0].setAttribute('patternTransform','translate(0,-'+(ph-gasket.e)/2+')');
$('#rightPattern')[0].setAttribute('patternTransform','translate(5,-'+(ph-gasket.e)/2+') rotate(180)');
*/
</script>
</body>
</html>