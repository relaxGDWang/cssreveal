<!DOCTYPE html>
<html lang="zh" xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="UTF-8">
  <title>css揭秘 例子实践</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
<div id="app">
  <div id="content">
    <h2><strong>{{showIndex}}</strong><span>{{show[sel].title}}</span></h2>
    <h1>CSS揭秘</h1>
    <div class="mainContent">
      <div class="outside">
        <!-- e1 -->
        <div id="e1" class="clearFloat" ref="e1">
          <div class="normalClip">边框透明，但看不出效果，原因在于背景颜色的裁剪模式，默认为background-clip:border-box</div>
          <div class="paddingClip">更改背景的裁剪范围，看上去就好多了，此时的裁剪模式为background-clip:padding-box;</div>
          <div class="ie8">
            <div class="ct">针对IE8做兼容调整，用z-index:-1不扩展html的结构下，虽然也能勉强实现，但副作用太大，目前采取还是多包一层dom的方法，并采用IE滤镜，但只能模拟实线边框</div>
          </div>
        </div>
        <!-- e2 -->
        <div id="e2" class="clearFloat" ref="e2">
          <div class="shadow">用box-shadow的扩展来模拟多层边框</div>
          <div class="shadowin">用inset把阴影设置在元素内部，从而让整个元素的事件响应范围保持正常</div>
          <div class="shadowin round">使用box-shadow的边框可以适应圆角</div>
          <div class="outline">outline实现的边框能使用边框样式，但无法适应圆角定义</div>
          <div class="outline2">通过outline的outline-offset的设置，完美实现缝纫线装饰</div>
        </div>
        <!-- e3 -->
        <div id="e3" class="clearFloat" ref="e3">
          <div class="p1">background-position扩展的特性可以被用来定位背景图和边框的距离，例如background-position:top 10px right 20px;</div>
          <div class="p2">
            使用background-origin来实现背景定位不同参照点的设定，当前是以padding-box的右下角作为参照点。如果背景图片大于容器大小，背景图片在background-clip设定的前提进行外溢
          </div>
          <div class="p3">使用calc来实现针对左上角的背景定位自适应</div>
        </div>
        <!-- e4 -->
        <div id="e4" class="clearFloat" ref="e4">
          <div class="p1">
            <div class="p1inside">用嵌套的两层dom实现内圆角框，好处在于兼容性比较优良，只要能支持圆角的浏览器就能正常响应</div>
          </div>
          <div class="p2">采用单层dom，使用样式outline和box-shadow实现的内圆角</div>
        </div>
        <!-- e5 -->
        <div id="e5" class="clearFloat" ref="e5">
          <div class="p1">普通线性渐变，设置两端的颜色值即可，浏览器会默认把两个颜色的占比平均分</div>
          <div class="p3">渐变过渡值为0，所以两端的值直接跳变了，看不到渐变的样子，全赖百分比设置</div>
          <div class="p5">使用background-size来固定背景图片的大小，然后让其产生重复，就达到了这个效果</div>
          <div class="p6">仅需增加linear-gradient的角度设定即可，注意把background-size也按竖向调整下</div>
          <div class="p8">调整了background-size后，依然不是我们想要的结果</div>
          <div class="p9">通过块状循环平铺和勾股定理的计算，45度的斜向可算完美展现，但并不适合于自定义角度</div>
          <div class="p10">使用repeating-linear-gradient实现渐变线条的角度更加简单</div>
          <div class="p11">更常用的同色系条纹，用背景色配合透明度的白色（黑色）条纹实现</div>
        </div>
        <!-- e6 -->
        <div id="e6" class="clearFloat" ref="e6">
          <div class="p1">使用CSS3的背景图片重叠很容易实现格子图案的背景</div>
          <div class="p2">透明的渐变纵横重叠之后，形成格子背景</div>
          <div class="p3"></div>
          <div class="p4"></div>
          <div class="p5"></div>
          <div class="p6"></div>
          <div class="p7"></div>
        </div>
        <!-- e7 -->
        <div id="e7" class="clearFloat" ref="e7">
          <div class="p1">规律的条纹背景，会形成视觉疲劳，这里是测试文本</div>
          <div class="p2">虽然进行了处理，不过依然可以发现规律，210像素的重复</div>
          <div class="p3">虽然使用蝉原则进行了协调，虽然整体似乎无规律，但实际第一背景条的间隔依然能辨识</div>
        </div>
      </div>
    </div>
    <div class="descript">
      <span class="descwords">{{show[sel].des}}</span>
    </div>
  </div>
  <div id="nav">
    <button v-for="(val,key) in show" v-on:click="showPage(key)">{{key}}</button>
  </div>
</div>
<script src="vue-2.5.9.min.js"></script>
<script src="index.js"></script>
</body>
</html>

<!--
两者都绑定点击事件
1.元素为祖先后代关系，即使两者不重叠，点击后代元素，会先触发后代元素的事件，然后触发祖先元素事件
2.两者不存在祖先后代关系，即使有重叠，会响应Z序上在上的元素，且不会触发到下面，产生了屏蔽效果
2.1 把z序靠上的元素设置为背景透明，再点击重叠部分，依然响应的是靠上元素的事件，下层元素同样不会响应
2.2 把靠下元素的position设置为relative/absolute/fixed，产生了定位，所以在z序关系上会显示在上面，响应特性不变
2.3 把设置了position的z-index:-1，测试下来主流浏览器其事件会被屏蔽，无法被触发，显示上也会跑到另一个元素下面被遮盖，但在IE8下显示不变，事件则不会被屏蔽
3.两者不为继承关系，b通过margin部分遮盖a，此时a的内容如果定位的重叠部分且b并非透明，奇怪的是a的元素却能在遮盖部分显示出来。IE8和主流浏览器都是如此，且这部分能响应a的click事件触发，且并不会触发b的事件
3.1，如果此时重叠部分有b的内容，b的内容会遮盖a的内容
4，两者不为继承关系，b通过position:absolute显示于a上，且有重叠部分，点击重叠部分仅触发b的事件。把b设置为透明，主流浏览器还是一样，但在IE8下，绝对定位的透明层对其覆盖下的a的内容部分无屏蔽功能，能正常点击a的button按钮并触发a的点击事件
4.1 在IE8下，假设给b的背景设置一个原色，并用filter:alpha(opacity=1)的透明对象滤镜设置b为透明，即使透明度设置的很高，看上去偏近透明，但只要不是transparent，依然可以起到屏蔽效果，哪怕把opacity=.1也是如此。
4.2 应当注意使用过滤滤镜来实现b的背景层半透明，此时不想alpha滤镜那样，只要有不透明度存在就可以屏蔽，无论过滤滤镜怎么设置，不会对这个下层内容的响应有任何屏蔽性。
以上是IE8的巨大问题，
-->